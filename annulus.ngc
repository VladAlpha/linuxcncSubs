(Vlad's annulus milling subroutine for ngcgui)
(takes a position and a few parameters to mill an annulus)
(tool number and feedrates should be defined prior to calling)

(arguments: 1[x center] 2[y center] 3[ID] 4[OD] 5[depth] 6[start of cut height])
( 7[z safe] [depth of cut per pass] [stepover percent] [feedrate])


F23

#1 =  0
#2 = 0
#3 = .9
#4 = 2
#5  = -.2
#6  = .05
#7  = .1
#8  = 25
#9  = 70
#10 = 24
#11 = [#5410*#9/100]

#<x> = #1       (=0)
#<y> = #2       (=0)
#<id> = #3
#<od> = #4
#<z_end> = #5 
#<zstart> = #6 (=.05: height to ramp in from, above material sugg)
#<z_safe> = #7 (=.1)
#<doc_p> = #8 (=25 : percent depth per pass)
#<sop> = #9 (=30 : percent stepover)
#<feed> = #10 (=24)
#<finish> = #11 (=[#5410*#<sop>/100] : default to step size)

#<tool_diam> = #5410
#<doc> = [#<tool_diam>*#<doc_p>/100]
#<step> = [#<tool_diam>*#<sop>/100]
#<z_curr> = [#<zstart>-#<doc>]  (convenient var for Z height)
(if depth can be done in one pass, reset z_curr)
    o10 if [#<z_curr> lt #<z_end>]
    #<z_curr> = #<z_end>
    o10 endif
    o20 if [#<tool_diam> eq 0]
    (msg, YOU MUST LOAD A NON 0 TOOL PRIOR TO USING ANNULUS)
    m2
    o20 endif
    
G40
F#<feed>            (set feedrate)
G00 Z#<z_safe>
G00 X#<x> Y#<y>     (go to center)
G92 X0 Y0           (set temp coordinate around center)
G00 X[#<tool_diam>/2] (prime for simple leadin 3 oclock park)
G41 (cut starts inside, left comp CW cutter and CW 02 arc)

#<rad> = [#<id>/2+#<finish>]              (convenient dim holder)
                                        (start finish dist from final ID)
(o<passes> sub)
    G00 X-#<rad> Z#<zstart>                      (lower to 9 start pos, also leadin)
    G02 I#<rad> Z#<z_curr> P1                    (ramp down in and cut circle)
    G02 I#<rad>                                  (clean cut)
    G02 X0 Y[#<id>/2] I#<rad> J[[#<id>*#<id>/4-#<rad>*#<rad>]/#<id>]    (arc into inner surface)
    G02 J-[#<id>/2] P1                              (clean inner surface)
    #<rad>= [#<rad>+#<tool_diam>]                   (sets rad to uncut wall dim)
    G00 X0 Y#<rad>                                  (moves to fresh surface 12)
    #<startRad> = #<rad>                            (save old value to shorten eqs)
    #<rad> = [#<rad>+#<step>]                       (set rad to next pass)
    
    o<expandingbulk> while [#<rad> le [[#<od>/2]-#<finish>]]    (keep pushing out, evals to final not cur dim)
        G03 X-#<rad> Y0 I[[#<rad>*#<rad>-#<startRad>*#<startRad>]/[-2*#<rad>]] J-[#<startRad>]  (arc out to 9)
        G03 X0 Y#<rad> I#<rad>                 (3/4 circle to 12)
        o<exitexpanding> if [[#<rad>+#<step>] lt [[#<od>/2]-#<finish>]] (check if next cut is <=od-finish, if so increment)
        #<startRad> = #<rad>                    (save old value to shorten eqs)
        #<rad> = [#<rad>+#<step>]               (keeps change nested but avoids extra final)
        o<exitexpanding> elseif [#<rad> eq [[#<od>/2]-#<finish>]]  (last rough was done, finish him!)
        #<startRad> = #<rad>                        (save it)
        #<rad> = [[#<od>/2]]                        (set to final value)
        G03 X-#<rad> Y0 I[[#<rad>*#<rad>-#<startRad>*#<startRad>]/[-2*#<rad>]] J-[#<startRad>]  (arc out to 9)
        G03 X0 Y#<rad> I#<rad>                 (3/4 circle to 12)
        G03 X-#<rad> Y0 J-#<rad>                    (finish cut)
        o<exitexpanding> else (next cut would have landed in finish region, so snap to)
        #<startRad> = #<rad>                        (save it)
        #<rad> = [[#<od>/2]-#<finish>]              (set to final rough value)
        o<exitexpanding> endif
    o<expandingbulk> endwhile
    
(o<passes> endsub)

#<zstart> = #<z_curr>
#<z_curr> = [#<z_curr>-#<doc>]

G00 Z#<z_safe>
G00 X#<x> Y#<y>
G92.1 G40

m2