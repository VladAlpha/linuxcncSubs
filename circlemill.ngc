(Vlad's annulus milling subroutine for ngcgui)
(takes a position and a few parameters to mill an annulus)
(tool number and feedrates should be defined prior to calling)

(arguments: 1[x center] 2[y center] 3[ID] 4[OD] 5[depth] 6[start of cut height])
( 7[z safe] [depth of cut per pass] [stepover percent] [feedrate])

o<circlemill> sub
#<tool> = #1    (=0 Tool | 0 == current)
#<rot> = #2     (=0 Spindle Rotation 3= CW 4 = CCW)
#<feedtype> = #3 (=0 climb = 1 conv = 2)
#<rpm> = #4     (=0 RPM | 0 == current)
#<feed> = #5    (=0 feed | 0 == current)
#<sop> = #6     (=30 stepover percent)
#<docp> = #7    (=25 percent z step)
#<zsafe> = #8   (=0.1 pre/post travel height)
#<x> = #9    (x position)
#<y> = #10   (y position)
#<zstart> = #11 (=0.05 start height of feature)
#<zend> = #12   (=-1: Bottom Z height) 
#<od> = #13     (diameter of milled hole)
#<finish> = #14 (=4: finish stepover, .010 for .25 tool)

#<tool_diam> = #5410
#<doc> = [#<tool_diam>*#<docp>/100]
#<step> = [#<tool_diam>*#<sop>/100]
#<z_curr> = [#<zstart>-#<doc>]  (convenient var for Z height)
#<finish> = [#<tool_diam>*#<finish>/100]

(set or modify or retain machine settings)
    o30 if [#<tool> gt 0] (set tool)
        M6 T#<tool>
        o30 endif
    o31 if [#<rot> gt 0] (start spindle )
        M#<rot>
        o31 endif
    o33 if [#<rpm> gt 0] (set spindle speed)
        S#<rpm>
        o33 endif
    o34 if [#<feed> gt 0]
        F#<feed>
        o34 endif
(if depth can be done in one pass, reset z_curr)
    o10 if [#<z_curr> lt #<zend>]
    #<z_curr> = #<zend>
    o10 endif
(o2n error checking)
    o20 if [#<tool_diam> eq 0]
    (msg, YOU MUST LOAD A NON 0 TOOL: FAIL AT CIRCLEMILL)
    m2
    o20 endif
    o22 if [#<tool_diam> gt #<od>]
    (msg, TOOL TOO LARGE: FAIL AT CIRCLEMILL)
    m2
    o22 endif

G40
G00 Z#<zsafe>
G00 X#<x> Y#<y>     (go to center)
G92 X0 Y0           (set temp coordinate around center)
G00 X[#<tool_diam>/2] (prime for simple leadin 3 oclock park)
G41 (cut starts inside, left comp CW cutter and CW 02 arc)

G00 X-#<rad> Z#<zstart>                      (lower to 9 start pos, also leadin)

o<layers> while [#<z_curr> ge #<zend>]         (if not too deep)
o<case> if [#<od> gt [2*[2*#<tool_diam>-#<step>]]] (mooltipass needed)
    G02 I#<rad> Z#<z_curr> P1                    (ramp down in and cut circle)
    G02 I#<rad>                                  (clean cut)
    G02 X0 Y[#<id>/2] I#<rad> J[[#<id>*#<id>/4-#<rad>*#<rad>]/#<id>]    (arc into inner surface)
    G02 J-[#<id>/2] P1                              (clean inner surface)
    #<rad>= [#<rad>+#<tool_diam>]                   (sets rad to uncut wall dim)
    G00 X0 Y#<rad>                                  (moves to fresh surface 12)
    #<startRad> = #<rad>                            (save old value to shorten eqs)
    #<rad> = [#<rad>+#<step>]                       (set rad to next pass)
    
    o<expandingbulk> while [#<rad> le [[#<od>/2]-#<finish>]]    (keep pushing out, evals to final not cur dim)
        G03 X-#<rad> Y0 I[[#<rad>*#<rad>-#<startRad>*#<startRad>]/[-2*#<rad>]] J-[#<startRad>]  (arc out to 9)
        G03 X0 Y#<rad> I#<rad>                 (3/4 circle to 12)
        o<exitexpanding> if [[#<rad>+#<step>] lt [[#<od>/2]-#<finish>]] (check if next cut is <=od-finish, if so increment)
        #<startRad> = #<rad>                    (save old value to shorten eqs)
        #<rad> = [#<rad>+#<step>]               (keeps change nested but avoids extra final)
        o<exitexpanding> elseif [#<rad> eq [[#<od>/2]-#<finish>]]  (last rough was done, finish him!)
        #<startRad> = #<rad>                        (save it)
        #<rad> = [[#<od>/2]]                        (set to final value)
        G03 X-#<rad> Y0 I[[#<rad>*#<rad>-#<startRad>*#<startRad>]/[-2*#<rad>]] J-[#<startRad>]  (arc out to 9)
        G03 X0 Y#<rad> I#<rad>                 (3/4 circle to 12)
        G03 X0 Y-#<rad> J-#<rad>                    (finish cut)
        o<exitexpanding> else (next cut would have landed in finish region, so snap to)
        #<startRad> = #<rad>                        (save it)
        #<rad> = [[#<od>/2]-#<finish>]              (set to final rough value)
        o<exitexpanding> endif
    o<expandingbulk> endwhile

    #<startRad>=#<rad>
    #<rad> = [#<id>/2+#<finish>]              (reset goal rad)
    G02 X-#<rad> Y0 I-[[#<rad>*#<rad>-#<startRad>*#<startRad>]/[2*#<rad>]] J#<startRad>  (go to inner start pos, 6>9)
o<case> elseif [#<od> eq [#<tool_diam>*2]] (one pass)
    G02 I#<rad> Z#<z_curr> P1   (circle plunge)
    G02 I#<rad>                 (finish bottom)
o<case> elseif [#<od> gt [#<tool_diam>*2] AND [#<od>-#<id>] le [2*[2*#<tool_diam>-#<step>]]] (two pass)
    G01 X-#<rad>
    G02 I#<rad> Z#<z_curr> P1   (circle plunge)
    G02 I#<rad> P1              (finish bottom)
    G01 X[-#<od>/2]             (move out)
    G03 I[#<od>/2] P2
o<case> endif

(set next layer height, if finished sets layer below final height)
    o<zcontrol> if [[#<z_curr>-#<doc>] gt #<zend>]   (if next cut makes sense but wont finish)
    #<z_curr> = [#<z_curr>-#<doc>]
    o<zcontrol> elseif [#<z_curr> eq #<zend>]          (if this cut just finished)
    #<z_curr> = [#<zend>-1]    (set excessive to quit)
    o<zcontrol> elseif [[#<z_curr>-#<doc>] le #<zend>]   (if next cut finishes or is excessive, force finish)
    #<z_curr> = #<zend>
    o<zcontrol> endif
o<layers> endwhile

G00 Z#<zsafe>
G00 X#<x> Y#<y>
G92.1 G40
o<circlemill> endsub
